# ÔºÅ/usr/bin/env python
# -*- coding:utf-8 -*-
# author:Niki
import numpy as np
import matplotlib.pyplot as plt

def compute_error(b,m,data):
    totalError = 0
    x = data[:,0]
    y = data[:,1]
    totalError = (y-m*x-b)**2
    totalError = np.sum(totalError,axis=0)
    return totalError/float(len(data))

def compute_gradient(b_current,m_current,data,learning_rate):
    #starting points or out gradients
    b_gradient = 0
    m_gradient = 0
    N = float(len(data))

    for i in range(0,len(data)):
        x = data[i,0]
        y = data[i,1]
        #computing partial derivations for our error function
        b_gradient+=-(2/N)*(y-((m_current*x)+b_current))
        m_gradient+=-(2/N)*x*(y-((m_current*x)+b_current))
        #updating our b&m values using out partial derivations
    new_b = b_current - (learning_rate*b_gradient)
    new_m = m_current - (learning_rate*m_gradient)
    return [new_b,new_m]
def optimizer(data,starting_b,starting_m,learning_rate,num_iter):
    b = starting_b
    m = starting_m
    #gradient decent
    for i in range(num_iter):
        # update b&m with the new more accurate b&m by performing this gradient step
        b, m = compute_gradient(b,m,data,learning_rate)
        if i%100 == 0:
            print('iter {0}:error={1}'.format(i,compute_error(b,m,data)))
    return [b, m]

def Linear_regression():
    data = np.loadtxt('.\data.csv',delimiter=',')
    learning_rate = 0.001
    initial_b = 0.0
    initial_m = 0.0
    num_iter = 10000
    print('initial variables:\n initial_b = {0}\n initial_m = {1}\n error of begin = {2}\n'\
          .format(initial_b,initial_m,compute_error(initial_b,initial_m,data)))
    [b, m] = optimizer(data,initial_b, initial_m, learning_rate, num_iter)
    print('final formula parmaters:\n b = {1}\n m={2}\n error of end = {3} \n'.format(num_iter, b, m,
                                                                                compute_error(b, m, data)))
if __name__ =='__main__':
    Linear_regression()
